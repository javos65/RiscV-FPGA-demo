// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
// ------------------------------------------------------------------
// Copyright (c) 2019-2023 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// ------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPEL
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
//
// ssd1306 led driver registers settingd for I2c added
// used for small AdaFruit 128x32 PIoled for Raspi HAT
// Details see : https://learn.adafruit.com/adafruit-pioled-128x32-mini-oled-for-raspberry-pi
//
// (c) 2024 Jay Fox
// MIT Open source
// github : https://github.com/javos65
//
// ------------------------------------------------------------------

#include "gpio.h"
#include "hal.h"
#include "utils.h"
#include <stdio.h>
#include "sys_platform.h"

#if (defined I2C0_INST_BASE_ADDR)
#include "i2c_master.h"
#include "ssd1306.h"
struct i2cm_instance i2c_core_i2c;
#endif

#if (defined LSCC_STDIO_UART_APB) && (defined UART_INST_BASE_ADDR)
#include "uart.h"
struct uart_instance uart_core_uart;
#endif

#ifndef _UART_NO_INTERRUPTS_
#include "pic.h"
#endif

struct gpio_instance gpio_inst;

static int lscc_uart_putc(char c, FILE *file)
{
#ifdef LSCC_STDIO_UART_APB
		int ret = EOF;
		ret = uart_putc(&uart_core_uart, c);
		if (c == '\n' && ret == 0)
			ret = uart_putc(&uart_core_uart, '\r');
		return ret;
#else
		return EOF;
#endif
}


static int lscc_uart_getc(FILE *file)
{
	(void) file;
	return EOF;
}


static int lscc_uart_flush(FILE *file)
{
	(void) file;
	return 0;
}


static void bsp_init(void)
{
	//initialize GPIO
	gpio_inst.instance_name = GPIO_INST_NAME;
	gpio_init(&gpio_inst, GPIO_INST_BASE_ADDR, GPIO_INST_LINES_NUM, GPIO_INST_GPIO_DIRS);

#if (defined LSCC_STDIO_UART_APB) && (defined UART_INST_BASE_ADDR)
#ifndef _UART_NO_INTERRUPTS_
	//setup uart IRQ
	pic_init(CPU0_INST_PICTIMER_START_ADDR);
	uart_core_uart.intrLevel = UART0_INST_IRQ;
	uart_core_uart.intrAvail = true;
	//pic_isr_register(UART0_INST_IRQ, uart_isr, (void *)&uart_core_uart);
#endif

	//initialize UART
	uart_init(&uart_core_uart, UART_INST_BASE_ADDR, UART_INST_SYS_CLK * 1000000, UART_INST_BAUD_RATE, 1, 8);
	iob_init(lscc_uart_putc, lscc_uart_getc, lscc_uart_flush);
#endif

#if (defined I2C0_INST_BASE_ADDR)
	i2c_master_config( &i2c_core_i2c, I2CM_ADDR_7BIT_MODE, INT_MODE, 87);   // see i2c_0 instance for 100Khz prescaler
	i2c_master_init(&i2c_core_i2c,I2C0_INST_BASE_ADDR);
#endif
}

//
// Quick and dirty I2C routines to drive a SSD1306 based oled on SCL and SDA pins
//

// Send i2C data string, pass code-array and size to send
void oled_send(uint8_t *data,uint16_t size)
{
	i2c_master_write(&i2c_core_i2c,SSD1306_ADR,size,data);
}

//Send lattice logo bmp data place at col/page location - to be replaced by an image structure
void oled_lattice(uint8_t column,uint8_t page)
{
	oled_graph[2]= column;oled_graph[3]=column+LATTICE_WIDTH-1;
	oled_graph[5]=page;oled_graph[6]=page+(LATTICE_HEIGHT/8)+1;						// put data into indexed setup array
	i2c_master_write(&i2c_core_i2c,SSD1306_ADR,sizeof(oled_graph),oled_graph); 		// send setup
	i2c_master_write(&i2c_core_i2c,SSD1306_ADR,LATTICE_SIZE, lattice1); 			// send data1
	i2c_master_write(&i2c_core_i2c,SSD1306_ADR,LATTICE_SIZE, lattice2); 			// send data2
}

// Fill the oled with a pattern : 128x32 bits ,in 512 bytes/
void oled_clear(uint8_t pattern)
{
	uint8_t i,d[9]={0x40,0,0,0,0,0,0,0,0}; 										   // data write (0x40) 8 bytes per transmission (avoid unwanted large data arrays)
	for(i=1;i<9;++i) d[i]=pattern;												   // fill patten in array
	oled_graph[2]=0;oled_graph[3]=127;oled_graph[5]=0;oled_graph[6]=4;			   // put command into indexed array Col 0-127, Pag 0-4
	i2c_master_write(&i2c_core_i2c,SSD1306_ADR,sizeof(oled_graph),oled_graph); 	   // send setup command
	for(i=0;i<SSD1306_D/8;++i) {i2c_master_write(&i2c_core_i2c,SSD1306_ADR,9,d);}; // send 8 data bytes in repeat
}



// main loop
int main(void) {
	static uint8_t idx = 0; // index 0
	static uint8_t pin_state = 0xFF; // all pins

	bsp_init();	delay(1000);
	printf("Hello RISC-V world!\n");
    delay(500);oled_send(oled_init,sizeof(oled_init)); 			    // init oled ssd1306
    delay(500);oled_clear(0xff);oled_send(oled_normal,2); 			// clear oled with pattern 0x00 - black
    delay(500);oled_lattice(0x04,0x00); 							// send lattice logo (upside down logo)

	while (true) {
		gpio_output_write(&gpio_inst, idx, pin_state);

		if (++idx == LED_COUNT) {  							// flip led state in acycle
			idx = 0;
			pin_state = ~pin_state;
		}

		if (RTL_SIM) {  									// delay in a cycle
			delay(1);
		} else {
			delay(250);
		}

		if (pin_state == 0xFF) {oled_send(oled_normal,2);}  //flip inverse
		else {oled_send(oled_inverse,2);}

		printf(".");										// send some data to Serial UART
	}

	return 0;
}



